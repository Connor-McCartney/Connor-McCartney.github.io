---
permalink: /cryptography/small-roots/push-it-to-the-limit-WACON-2023-prequal
title: Push It To The Limit - WACON 2023 Prequal
---

<br>

# Challenge Files

```python
from Crypto.Util.number import bytes_to_long, getStrongPrime

with open("flag.txt", "rb") as f:
    m = bytes_to_long(f.read())

SIZE = 1024
p = getStrongPrime(SIZE)
q = getStrongPrime(SIZE)
n = p * q
e = 0x10001
c = pow(m, e, n)

p_msb = p - p % (2 ** (SIZE // 2))

print(f"{n = }")
print(f"{c = }")
print(f"{p_msb = }")
```

```
n = 24712135189687942739677490021030751776088469214818275631687482073531676912880823269667196936095460153002434759403063429337125873794523587731746689517070810687221399532024093572951282737818446579992570629531618780373767724789390101166147862982539311016801595612323156816999866783427829783286164172896802725820761659256555627406518829192800217880692359914672894220547306033679060066475600137205045054015651689487444267401130160872050085589597109014374199731072611044277806027332254214020499883131062627540945260814416104971893858787291926267157394988131329441246648393933117451348643609850156730059817506513924523851733
c = 19285290054358264594160191119053363484661054622854927550086540936229836207751905061897299540539735528766803248513199392889410922209106513019275525361297785136742517684745274089253401778969310170805452788203125136583847273167894915706201708268160138117578035286292385848441833691098676192230945185815890266453215404593242520989429750775723053435372661531195966551199012453469748764989624596296116016310586535749198878013241527430239006604194528859329192316989103910514620735894760979900228995139208829267762309798970482895132300580481270883276800390489213520429816698576642899381455153039281329012831320123165127378159
p_msb = 161405912451824860188834725646055524173328544131300133372580621368926433914138476338787007253318242142454894032713487340762003643551953941809023233323836630063065828499586237941251339865726273353740523275987884928619323490566227483094269770052935277592758770273832919929071652425379016974435907024060290170880
```

# Solve

Didn't play this ctf btw, just a post-solve. <br>
It's very similar to this one. <br>
<https://connor-mccartney.github.io/cryptography/small-roots/corrupt-key-1-picoMini> <br>
Half of the upper bits of p are given, the only difference is now p is 1024 bits not 512 bits. <br>
This makes it a lot slower, so I edited my previous code to include 3 optimisations from maple3142. 

# Optimisation 1

Since p must be odd, we can reduce the search range by 1 bit by changing

```python
        f = p_high * 2**(p_bits-p_high_bits) + x
        x = small_roots(f, X=2**(p_bits-p_high_bits), beta=0.4999, m=m)
```

to 

```python
        f = p_high * 2**(p_bits-p_high_bits) + 2*x + 1
        x = small_roots(f, X=2**(p_bits-p_high_bits-1), beta=0.4999, m=m)
```

# Optimisation 2

Using flatter for faster LLL. 

```
sudo pacman -S eigen --noconfirm
cd ~/Documents
git clone https://github.com/keeganryan/flatter
cd flatter
cmake .
make -j4
sudo ln -s ~/Documents/flatter/bin/flatter /usr/local/bin/flatter
```

```python
from subprocess import check_output
from re import findall

def flatter(M):
    z = "[[" + "]\n[".join(" ".join(map(str, row)) for row in M) + "]]"
    ret = check_output(["flatter"], input=z.encode())
    return matrix(M.nrows(), M.ncols(), map(int, findall(b"-?\\d+", ret)))
```

And now we can do `B =  flatter(B)` instead of `B = B.LLL()`

# Experiment

Here's the full value of p:

```python
p = 161405912451824860188834725646055524173328544131300133372580621368926433914138476338787007253318242142454894032713487340762003643551953941809023233323836632396674586164821404065443903169766781702197174899338334027128103867874700640036605974611327518250687560220955598412727224450293311080620976484498655311739
```



