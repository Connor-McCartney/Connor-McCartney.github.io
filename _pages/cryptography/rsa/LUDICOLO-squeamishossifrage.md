---
permalink: /cryptography/rsa/LUDICOLO-squeamishossifrage
title: LUDICOLO - squeamishossifrage
---

<br>

[Challenge](https://github.com/zerosumsecurity/squeamishossifrage/tree/main/LUDICOLO)

<br>

# Overview

This is one of my favourite challenges ever!

The description says "We have a bunch of certificates and a flag that is encrypted for one of these certificates. All RSA parameters underlying these certificates were generated by the same source."

We then have a folder of 1000 certificates which contains 1000 RSA moduli. 

Each modulus is of the form (for unknown g, M and random k's, a's):

$$n = (k_1 \cdot M + (g^{a_1} \text{ (mod } M \text{)})) \cdot (k_2 \cdot M + (g^{a_2} \text{ (mod } M \text{)}))$$

# Reading the certs

`git clone https://github.com/zerosumsecurity/squeamishossifrage && mv ./squeamishossifrage/LUDICOLO ./LUDICOLO`

There's 2 non-unicode filenames, we'll just rename them:

`cd ./LUDICOLO/certificates && mv 'NO'$'\353''LLE.crt' 'NOELLE.crt' && mv 'DANI'$'\353''LLE.crt' 'DANIELLE.crt' && cd ..`

Then we can read them:

```python
from Crypto.PublicKey import RSA
from os import listdir

for cert in listdir("certificates"):
    key = RSA.import_key(open(f"certificates/{cert}", "rb").read())
    print(f"{cert}\n{key.n = }\n{key.e = }\n\n")
```

You can observe that e = `21558488234539889837938770635971330903489839146766895224490179041465516193145582266963154883831707522081140734421052039099233464837201660281606980530249` 

for every cert, but e won't be used to factor any of the moduli.

# Handling unknown g and M

The code used to create the vulnerable primes is not given to us so it's basically impossible to bruteforce what the real value of g is. 

So, we'll have to create our own new valid g.

Expanding our equation for n yields:

$$n \equiv  g^{a_1 + a_2}  \text{ (mod } M \text{)}$$

As such, testing whether or not the discrete log `Zmod(M)(n).log(g)` exists is a good way to test if the paramaters are suitable.

All the n's are 1024 bits, so M is some primorial 0 < M < 2**512. For now let's just set M as primorial(44) which is 257 bits, <br>
(it's probably bigger but meh we're just going to use it to find a good g and then we'll come back to M).

Now since we've shown n is a power of g mod M, we can choose g to be one of the n's!

The ideal g will have the highest order mod M and pass the discrete log test for all n's:

```python
from Crypto.PublicKey import RSA
from os import listdir

ns = []
for cert in listdir("certificates"):
    key = RSA.import_key(open(f"certificates/{cert}", "rb").read())
    ns.append(key.n)

M = prod(Primes()[:44])
orders = [(Zmod(M)(g).multiplicative_order(), g) for g in ns]
g = max(orders)[1]
print(f"{g = }")
```

This spits out: `g = 124487484906862841716197271099288982418112339712300503532811587529290282070741393095312005224387582755588498588422611085050656924777128366585922973222106128294698530803880136848394814736494132569717601758206266058059480149764779347375471688251307463397885640587176752552571821368775747843170717099871242658691`

Now let's go back to M, we'll try increasing primorials until the discrete log test fails:

```python
g = 124487484906862841716197271099288982418112339712300503532811587529290282070741393095312005224387582755588498588422611085050656924777128366585922973222106128294698530803880136848394814736494132569717601758206266058059480149764779347375471688251307463397885640587176752552571821368775747843170717099871242658691
i = 44
while True:
    M = prod(Primes()[:i])
    try:
        for n in ns:
            _ = Zmod(M)(n).log(g)
    except:
        break
    i += 1
print(i)
```

It fails on primorial(75), making me guess the author used M = primorial(74).

# Optimising M'

To reduce the search space for the ROCA attack, we can choose M' = some divisor of M.

The ideal M' will have a small order (for a smaller searchspace to brute) but also be big enough <br>
for coppersmith to succeed.

Additionally, a bigger lattice dimension (m) is necessary for smaller M', but will cause <br>
LLL to take longer to complete, so there is a tradeoff between searchspace and LLL computation time to consider. 

