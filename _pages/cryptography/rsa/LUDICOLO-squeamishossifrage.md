---
permalink: /cryptography/rsa/LUDICOLO-squeamishossifrage
title: LUDICOLO - squeamishossifrage
---

<br>

[Challenge](https://github.com/zerosumsecurity/squeamishossifrage/tree/main/LUDICOLO)

<br>

# Overview

This is one of my favourite challenges ever!

The description says "We have a bunch of certificates and a flag that is encrypted for one of these certificates. All RSA parameters underlying these certificates were generated by the same source."

We then have a folder of 1000 certificates which contains 1000 RSA moduli. 

Each modulus is of the form (for unknown g, M and random k's, a's):

$$n = (k_1 \cdot M + (g^{a_1} \text{ (mod } M \text{)})) \cdot (k_2 \cdot M + (g^{a_2} \text{ (mod } M \text{)}))$$

# Reading the certs

`git clone https://github.com/zerosumsecurity/squeamishossifrage && mv ./squeamishossifrage/LUDICOLO ./LUDICOLO`

There's 2 non-unicode filenames, we'll just rename them:

`cd ./LUDICOLO/certificates && mv 'NO'$'\353''LLE.crt' 'NOELLE.crt' && mv 'DANI'$'\353''LLE.crt' 'DANIELLE.crt' && cd ..`

Then we can read them:

```python
from Crypto.PublicKey import RSA
from os import listdir

for cert in listdir("certificates"):
    key = RSA.import_key(open(f"certificates/{cert}", "rb").read())
    print(f"{cert}\n{key.n = }\n{key.e = }\n\n")
```

You can observe that e = `21558488234539889837938770635971330903489839146766895224490179041465516193145582266963154883831707522081140734421052039099233464837201660281606980530249` 

for every cert, but e won't be used to factor any of the moduli.

# Handling unknown g and M

The code used to create the vulnerable primes is not given to us so it's basically impossible to bruteforce what the real value of g is. 

So, we'll have to create our own new valid g.

Expanding our equation for n yields:

$$n \equiv  g^{a_1 + a_2}  \text{ (mod } M \text{)}$$

As such, testing whether or not the discrete log `Zmod(M)(n).log(g)` exists is a good way to test if the paramaters are suitable.

All the n's are 1024 bits, so M is some primorial 0 < M < 2**512. For now let's just set M as primorial(44) which is 257 bits, <br>
(it's probably bigger but meh we're just going to use it to find a good g and then we'll come back to M).

Now since we've shown n is a power of g mod M, we can choose g to be one of the n's!

The ideal g will have the highest order mod M and pass the discrete log test for all of the n's:
