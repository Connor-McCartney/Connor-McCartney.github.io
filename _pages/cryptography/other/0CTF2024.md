---
permalink: /cryptography/other/0CTF2024
title: 0CTF 2024
---


<br>

<br>

<https://github.com/sh1k4ku/ctf-challenge/tree/main/0CTF2024>

<br>



# dbot

<br>

Level 0:

Setup:

```python
from Crypto.Util.number import *
flag = b'flag{test}'
ROUND = 80
primes = [getPrime(512) for _ in range(3)]

N = prod(primes)
phi = prod([(pp - 1) for pp in primes])
d = inverse(0x10001, phi)
m = bytes_to_long(os.urandom(N.bit_length() // 8 - 2))
c = pow(m, 0x10001, N)


#idx = int(input("Choose one prime you prefer: "))
idx = 0 # doesn't matter...
assert idx in list(range(len(primes))), "No such prime"
mod = primes.pop(idx)
print(f"Here is your prime: {mod}")
print(f"{c = }")
print(f"{N = }")

a = [getrandbits(496) for _ in range(ROUND)]
b = getrandbits(248)
c = [getrandbits(496) for _ in range(ROUND)]
e = b
ph1 = [prod([(primes[0] + a[i]), (primes[1] + b)]) for i in range(ROUND)]
ph2 = [prod([(-primes[0] + c[i]), (primes[1] + e)]) for i in range(ROUND)]

for i in range(ROUND):
    x0 = randrange(0, N)
    x1 = randrange(0, N)
    print(f"{x0 = }")
    print(f"{x1 = }")
    v = int(input("Give me v: "))
    m0 = (pow(v - x0, d, mod) + ph1[i]) % mod
    m1 = (pow(v - x1, d, mod) + ph2[i]) % mod
    print(f"{m0 = }")
    print(f"{m1 = }")


m_ = int(input("Give me m: "))
if m_ == m:
    print("Good job!")
else:
    print("Try again!")
```

<br>

We have some `N = p*q*r`, we're given one of the factors, and goal is to factor N so we can solve m. 

First we need to choose some useful v. 



<br>

<br>

# Signin

<br>

The first time LLL has betrayed me...

It seems the stronger BKZ is needed. 

A small discusison:

```
ConnorM (me):
is there any heuristic to choose BKZ block size? or just trial and error

grhkm:
Vibes

tl2cents:
maybe the root  hermite factor δ. The shortest LLL/BKZ-reduced vector satisfies ||b1|| < δ^n det(L)^(1/n). LLL has a practical roote hermite factor of 1.021 and for BKZ-20, it is 1.013.

grhkm:
this should be a sage feature :P

tl2cents:
according to this paper, it seems like an algorithmic thing. https://www.iacr.org/archive/eurocrypt2008/49650031/49650031.pdf
```

<br>

Solve:


The error terms e are generated by this suspicious ternary function:

```python
import random
import numpy as np
from string import ascii_lowercase

def ternary_sample(n, ternaryL, SecureRandom):
    return [ternaryL[int(_)] for __ in range(n // 5) for _ in np.base_repr(ord(SecureRandom.choice(ascii_lowercase)), 3)]

m = 220
e_L = [0, 101, 731]
R_e = random.SystemRandom()
e = np.array(ternary_sample(m, e_L, R_e))
print(e.tolist())
```

<br>

If you look at this, another observation you can make it the base 3 representation of all the ascii chars all begin with 1:

```python
while True:
    print([np.base_repr(ord(random.choice(ascii_lowercase)), 3)])
```

<br>

So, every 5th element of e will be ternaryL[1] which is 101. 


Another observation:

```python
q = next_prime(1337)
assert 2*731 % q == 101
print([int(i) * pow(731, -1, q) % q for i in e])
print([int(i) * pow(731, -1, q) % q for i in e][::5])
```

Now e becomes even smaller, all either 0 1 or 2 and every 5th being 2. If you count every 5th, we have 44 known ei. 

We can also subtract 1 from our equations to center ei at either -1, 0 or 1. 


```python

for Ai, bi, ei in zip(A, b, e):
    assert bi == (sum([aa*ss for aa, ss in zip(Ai, s)]) + ei) % q
    z = pow(731, -1, q)
    assert (- sum([aa*z*ss for aa, ss in zip(Ai, s)]) + bi*z - 1) % q == (ei*z-1) % q
    assert (ei*z-1) % q in [-1%q, 0, 1]
```


<br>

Test:
