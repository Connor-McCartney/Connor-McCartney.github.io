---
permalink: /cryptography/other/FCSC-2025
title: France Cybersecurity Challenge 2025
---

<br>

<br>



# ProblÃ¨meuh

```python
import sys
from hashlib import sha256
sys.set_int_max_str_digits(31337)
try:
    a, b, c, x, y = [ int(input(f"{x} = ")) for x in "abcxy" ]
    assert a > 0
    assert a == 487 * c
    assert 159 * a == 485 * b
    assert x ** 2 == a + b
    assert y * (3 * y - 1) == 2 * b
    h = sha256(str(a).encode()).hexdigest()
    print(f"FCSC{{{h}}}")
except:
    print("Nope!")
```

<br>


<br>

<br>

---

# Kzber

![image](https://github.com/user-attachments/assets/eb3c1504-88f0-4c39-ac14-da8ef28c37d5)


```python
import os
import json
import zlib
import base64
import pickle
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from sage.all import *

class Kzber:
    def __init__(self, q = 3329, d = 256, k = 2, B = 2):
        self.q = q
        self.d = d
        self.k = k
        self.B = B
        Zq, Y = PolynomialRing(GF(q), 'Y').objgen()
        R, X = Zq.quotient_ring(Y**d - 1, 'X').objgen()
        self.R = R
        self.X = X
        self._keygen()

    def _sample_short_poly(self):
        coeffs = [randint(-self.B, self.B) for i in range(self.d)]
        return self.R(coeffs)

    def _sample_short_vector(self):
        return vector(self.R, [self._sample_short_poly(), self._sample_short_poly()]).column()

    def _keygen(self):
        A = random_matrix(self.R, 2, 2)
        s  = self._sample_short_vector()
        e1 = self._sample_short_vector()
        t = A * s + e1
        self.sk = s
        self.pk = (A, t)

    def encrypt(self, m):
        A, t = self.pk
        r  = self._sample_short_vector()
        e2 = self._sample_short_vector()
        e3 = self._sample_short_poly()
        u = r.transpose() * A + e2.transpose()
        v = r.transpose() * t + e3 + (int(round(self.q/2)) * self.R(m))
        return u, v
    
    def decrypt(self, c):
        u, v = c
        w = (v - u * self.sk)[0, 0]
        coeffs = list(w)
        coeffs = [int(wi) if int(wi) < self.q//2 else int(wi) - self.q for wi in coeffs]
        return [0 if abs(wi) <= self.q//4 else 1 for wi in coeffs]

PKE = Kzber()
A, t = PKE.pk
sk = randint(0, 2 ** 128)
C = [ PKE.encrypt(int(m)) for m in f"{sk:0128b}" ]

flag = open("flag.txt", "rb").read()
iv = os.urandom(16)
E = AES.new(int.to_bytes(sk, 16), AES.MODE_CBC, iv = iv)
enc = E.encrypt(pad(flag, 16))

print(base64.b64encode(zlib.compress(pickle.dumps({
    "A": A,
    "t": t,
    "C": C,
    "flag" : {
        "iv": iv,
        "enc": enc,
    }
}))).decode())
```

<br>



Solve:

The typo is in the quotient ring. `Y**d - 1` should be `Y**d + 1`

<https://eprint.iacr.org/2024/1287.pdf> (section 4.5)

<https://crypto.stackexchange.com/questions/103373/choice-of-polynomial-quotient-ring>


<br>

```python
sage: (Y**256 - 1).factor()
(Y^128 + 1)*(Y^64 + 1)*(Y^32 + 1)*(Y^16 + 1)*(Y^8 + 1)*(Y^4 + 1)*(Y^2 + 1)*(Y + 1)*(Y - 1)
```

<br>

Let's focus on just Y^128 + 1.



---

First a look at an example of multiplying 2 polynomials in a ring. 



```python
sage: q = 3329
....: d = 3
....: Zq.<Y> = PolynomialRing(GF(q))
....: R.<X> = Zq.quotient_ring(Y**d + 1)
....: 
....: 
....: f = 7*X^2 + 3*X + 4
....: g = 9*X^2 + 8*X + 6
....: print(f*g)
....: 
102*X^2 + 3316*X + 3270
```

How can we get that manually?

First multiply normally (ZZ):

```python
sage: var('X')
X
sage: f = 7*X^2 + 3*X + 4
sage: g = 9*X^2 + 8*X + 6
sage: (f*g).expand()
63*X^4 + 83*X^3 + 102*X^2 + 50*X + 24
```

Now how do you do a polynomial modulo another polynomial? You can divide with polynomial long division, then take the remainder r. 

```python
63*X^4 + 83*X^3 + 102*X^2 + 50*X + 24 = q + r/(X^3 + 1)
```

<https://www.symbolab.com/solver/polynomial-long-division-calculator/long%20division%20%5Cfrac%7B63%5Ccdot%20X%5E%7B4%7D%20%2B%2083%5Ccdot%20X%5E%7B3%7D%20%2B%20102%5Ccdot%20X%5E%7B2%7D%20%2B%2050%5Ccdot%20X%20%2B%2024%7D%7BX%5E%7B3%7D%20%2B%201%7D?or=input>



<br>

