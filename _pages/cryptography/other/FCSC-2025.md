---
permalink: /cryptography/other/FCSC-2025
title: France Cybersecurity Challenge 2025
---

<br>

<br>



# ProblÃ¨meuh

```python
import sys
from hashlib import sha256
sys.set_int_max_str_digits(31337)
try:
    a, b, c, x, y = [ int(input(f"{x} = ")) for x in "abcxy" ]
    assert a > 0
    assert a == 487 * c
    assert 159 * a == 485 * b
    assert x ** 2 == a + b
    assert y * (3 * y - 1) == 2 * b
    h = sha256(str(a).encode()).hexdigest()
    print(f"FCSC{{{h}}}")
except:
    print("Nope!")
```

<br>


<br>

<br>

---

# Kzber

![image](https://github.com/user-attachments/assets/eb3c1504-88f0-4c39-ac14-da8ef28c37d5)


```python
import os
import json
import zlib
import base64
import pickle
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from sage.all import *

class Kzber:
    def __init__(self, q = 3329, d = 256, k = 2, B = 2):
        self.q = q
        self.d = d
        self.k = k
        self.B = B
        Zq, Y = PolynomialRing(GF(q), 'Y').objgen()
        R, X = Zq.quotient_ring(Y**d - 1, 'X').objgen()
        self.R = R
        self.X = X
        self._keygen()

    def _sample_short_poly(self):
        coeffs = [randint(-self.B, self.B) for i in range(self.d)]
        return self.R(coeffs)

    def _sample_short_vector(self):
        return vector(self.R, [self._sample_short_poly(), self._sample_short_poly()]).column()

    def _keygen(self):
        A = random_matrix(self.R, 2, 2)
        s  = self._sample_short_vector()
        e1 = self._sample_short_vector()
        t = A * s + e1
        self.sk = s
        self.pk = (A, t)

    def encrypt(self, m):
        A, t = self.pk
        r  = self._sample_short_vector()
        e2 = self._sample_short_vector()
        e3 = self._sample_short_poly()
        u = r.transpose() * A + e2.transpose()
        v = r.transpose() * t + e3 + (int(round(self.q/2)) * self.R(m))
        return u, v
    
    def decrypt(self, c):
        u, v = c
        w = (v - u * self.sk)[0, 0]
        coeffs = list(w)
        coeffs = [int(wi) if int(wi) < self.q//2 else int(wi) - self.q for wi in coeffs]
        return [0 if abs(wi) <= self.q//4 else 1 for wi in coeffs]

PKE = Kzber()
A, t = PKE.pk
sk = randint(0, 2 ** 128)
C = [ PKE.encrypt(int(m)) for m in f"{sk:0128b}" ]

flag = open("flag.txt", "rb").read()
iv = os.urandom(16)
E = AES.new(int.to_bytes(sk, 16), AES.MODE_CBC, iv = iv)
enc = E.encrypt(pad(flag, 16))

print(base64.b64encode(zlib.compress(pickle.dumps({
    "A": A,
    "t": t,
    "C": C,
    "flag" : {
        "iv": iv,
        "enc": enc,
    }
}))).decode())
```

<br>



Solve:

The typo is in the quotient ring. `Y**d - 1` should be `Y**d + 1`

<https://eprint.iacr.org/2024/1287.pdf> (section 4.5)

<https://crypto.stackexchange.com/questions/103373/choice-of-polynomial-quotient-ring>


<br>

```python
sage: (Y**256 - 1).factor()
(Y^128 + 1)*(Y^64 + 1)*(Y^32 + 1)*(Y^16 + 1)*(Y^8 + 1)*(Y^4 + 1)*(Y^2 + 1)*(Y + 1)*(Y - 1)
```

<br>

Let's focus on just Y^128 + 1.



---

First a look at an example of multiplying 2 polynomials in a ring. 



```python
sage: q = 3329
....: d = 3
....: Zq.<Y> = PolynomialRing(GF(q))
....: R.<X> = Zq.quotient_ring(Y**d + 1)
....: 
....: 
....: f = 7*X^2 + 3*X + 4
....: g = 9*X^2 + 8*X + 6
....: print(f*g)
....: 
102*X^2 + 3316*X + 3270
```

How can we get that manually?

First multiply normally (ZZ):

```python
sage: var('X')
X
sage: f = 7*X^2 + 3*X + 4
sage: g = 9*X^2 + 8*X + 6
sage: (f*g).expand()
63*X^4 + 83*X^3 + 102*X^2 + 50*X + 24
```

Now how do you do a polynomial modulo another polynomial? You can divide with polynomial long division, then take the remainder. 

```python
(63*X^4 + 83*X^3 + 102*X^2 + 50*X + 24)/(X^3 + 1) = quotient + remainder/(X^3 + 1)
```

<https://www.symbolab.com/solver/polynomial-long-division-calculator/long%20division%20%5Cfrac%7B63%5Ccdot%20X%5E%7B4%7D%20%2B%2083%5Ccdot%20X%5E%7B3%7D%20%2B%20102%5Ccdot%20X%5E%7B2%7D%20%2B%2050%5Ccdot%20X%20%2B%2024%7D%7BX%5E%7B3%7D%20%2B%201%7D?or=input>

We get remainder `102*X^2 - 13*X - 59`

<br>

The final step is to just take all the coefficients mod q. 

```python
sage: q = 3329
sage: -13 % q
3316
sage: -59 % q
3270
```

And now we've reached the same correct answer, `102*X^2 + 3316*X + 3270`

---

Depending on your quotient ring, there are nicer formulas. 

I implemented this one <https://crypto.stackexchange.com/questions/99866/modular-reduction-in-the-ring-mathbbz-qx-xn-1> for X^d + 1

```python
q = 3329
#d = 128
d = 3
Zq.<Y> = PolynomialRing(GF(q))
R.<X> = Zq.quotient_ring(Y**d + 1)

f = R.random_element()
g = R.random_element()

print(f*g)


def poly_mul_quotient_ring(f, g, d, q):
    # polynomial multiplication in the quotient ring X^d + 1 mod q
    Rq.<z> = PolynomialRing(GF(q))
    f = Rq(f.list())
    g = Rq(g.list())

    ff = f.list()
    gg = g.list()
    ff += [0] * (d - len(ff)) 
    gg += [0] * (d - len(gg)) 

    s1 = 0
    for i in range(d):
        for j in range(d-i):
            s1 += ff[i] * gg[j] * z**(i+j)

    s2 = 0
    for i in range(1, d):
        for j in range(d-i, d):
            s2 += ff[i] * gg[j] * z**(i+j-d)
    return s1 - s2

print(poly_mul_quotient_ring(f, g, d, q))
```

<br>

---


<br>

We ultimately want to break the LWE thing in the keygen with LLL

```py
    def _keygen(self):
        A = random_matrix(self.R, 2, 2)
        s  = self._sample_short_vector()
        e1 = self._sample_short_vector()
        t = A * s + e1
```

<br>

Let's visualise this:

```python
class Kzber:
    #def __init__(self, q = 3329, d = 256, k = 2, B = 2):
    def __init__(self, q = 3329, d = 3, k = 2, B = 2):
        self.q = q
        self.d = d
        self.k = k
        self.B = B
        Zq, Y = PolynomialRing(GF(q), 'Y').objgen()
        R, X = Zq.quotient_ring(Y**d + 1, 'X').objgen()
        self.R = R
        self.X = X
        self._keygen()

    def _sample_short_poly(self):
        coeffs = [randint(-self.B, self.B) for i in range(self.d)]
        return self.R(coeffs)

    def _sample_short_vector(self):
        return vector(self.R, [self._sample_short_poly(), self._sample_short_poly()]).column()

    def _keygen(self):
        A = random_matrix(self.R, 2, 2)
        s  = self._sample_short_vector()
        e = self._sample_short_vector()
        t = A * s + e
        self.sk = s
        self.pk = (A, t)
        self.e = e

PKE = Kzber()
q = PKE.q
d = PKE.d
A, t = PKE.pk
s = PKE.sk
e = PKE.e

assert t - A*s == e

Zq.<Y> = PolynomialRing(GF(q))
R.<X> = Zq.quotient_ring(Y**d + 1)
A00 = R(list(A[0][0]))
A01 = R(list(A[0][1]))
A10 = R(list(A[1][0]))
A11 = R(list(A[1][1]))

s0 = R(list(s[0][0]))
s1 = R(list(s[1][0]))
t0 = R(list(t[0][0]))
t1 = R(list(t[1][0]))

assert t0 - s0*A00 - s1*A01 == e[0][0]
assert t1 - s0*A10 - s1*A11 == e[1][0]
```

<br>

Now let's use my own poly_mul_quotient_ring function I wrote:

```python
def m(f, g):
    ff = f.list()
    gg = g.list()
    ff += [0] * (d - len(ff)) 
    gg += [0] * (d - len(gg)) 

    s1 = 0
    for i in range(d):
        for j in range(d-i):
            s1 += ff[i] * gg[j] * Y**(i+j)

    s2 = 0
    for i in range(1, d):
        for j in range(d-i, d):
            s2 += ff[i] * gg[j] * Y**(i+j-d)
    return s1 - s2

PKE = Kzber()
q = PKE.q
d = PKE.d
A, t = PKE.pk
s = PKE.sk
e = PKE.e

assert t - A*s == e

Zq.<Y> = PolynomialRing(GF(q))
A00 = Zq(list(A[0][0]))
A01 = Zq(list(A[0][1]))
A10 = Zq(list(A[1][0]))
A11 = Zq(list(A[1][1]))

s0 = Zq(list(s[0][0]))
s1 = Zq(list(s[1][0]))
t0 = Zq(list(t[0][0]))
t1 = Zq(list(t[1][0]))

assert t0 - m(s0, A00) - m(s1, A01) == e[0][0]
assert t1 - m(s0, A10) - m(s1, A11) == e[1][0]
```

<br>

Rewrite again to just deal with arrays instead of sage polynomials:
